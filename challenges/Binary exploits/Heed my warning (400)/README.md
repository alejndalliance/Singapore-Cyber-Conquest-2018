## Heed my warning

**Category :** Binary exploits

**Points :** 400

**Solves :** -

**Description :**
Try building it: gcc -m32 -Wall -ansi source.c -o runme

ssh pwn.baectf.com
Credentials: username 'pwn018', password 'africanswallow'

**Hint :** 
- 1 point hint: We recommend building this and paying attention to the warning!
- 25 point hint: The return value of the strcmp call ends up being used as the return value of the whole program
- 50 point hint: Analyse how the return address of the program changes depending on the input you give it. Work out the password a character at a time.

### Write-up

For this challenge, we didn't manage to finish it up on the competition day.  

So, I asked `amon` (from NUS Greyhats) on how he solved it. He said that `strcmp()` return value `eax` is being return to the system.

To confirm it, look at below `main` diassembly:

```
$ r2 -A runme 
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Constructing a function name for fcn.* and sym.func.* functions (aan)
[x] Type matching analysis for all functions (afta)
[x] Use -AA or aaaa to perform additional experimental analysis.
 -- The door can see into your soul.
[0x080484e0]> pdf main
This block size is too big (52428800<134514141). Did you mean 'pd @ 0x080485dd' instead?
[0x080484e0]> pd @ 0x080485dd
            ;-- main:
┌ (fcn) sym.main 265
│   sym.main (int argc, char **argv, char **envp);
│           ; arg unsigned int arg_8h @ ebp+0x8
│           ; arg int arg_ch @ ebp+0xc
            ...
│           0x080486a4      8b00           mov eax, dword [eax]
│           0x080486a6      89442404       mov dword [size], eax       ; const char *s2
│           0x080486aa      8d442418       lea eax, dword [s1]         ; 0x18 ; 24
│           0x080486ae      890424         mov dword [esp], eax        ; const char *s1
│           0x080486b1      e87afdffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
│           0x080486b6      85c0           test eax, eax
│       ┌─< 0x080486b8      7518           jne 0x80486d2
│       │   0x080486ba      c70424ae8704.  mov dword [esp], str.Winning ; [0x80487ae:4]=0x6e6e6957 ; "Winning!" ; const char *s
│       │   0x080486c1      e8aafdffff     call sym.imp.puts           ; int puts(const char *s)
│       │   0x080486c6      c70424000000.  mov dword [esp], 0          ; int status
│       │   0x080486cd      e8befdffff     call sym.imp.exit           ; void exit(int status)
│       │   ; CODE XREF from sym.main (0x80486b8)
│       └─> 0x080486d2      8b54247c       mov edx, dword [canary]     ; [0x7c:4]=-1 ; '|' ; 124
│           0x080486d6      653315140000.  xor edx, dword gs:[0x14]
│       ┌─< 0x080486dd      7405           je 0x80486e4
│       │   0x080486df      e86cfdffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)
│       │   ; CODE XREF from sym.main (0x80486dd)
│       └─> 0x080486e4      c9             leave
└           0x080486e5      c3             ret
            ...
```

As we can see, `eax` isn't being cleared after `strcmp()` call, so that value is being treated as `main()` return value.

So, what `strcmp()` actually return?

Looking at the man-page:

```
RETURN VALUE
       The strcmp() and strncmp() functions return an integer less than, equal to, or greater than zero if s1 (or the first n bytes thereof) is found, respectively, to be less than, to
       match, or be greater than s2.
```

So, we have the idea now?

At the actual competition day, `key.txt` contains the actual flag that we need to retrieve. As I didn't solve it, so I don't know the content. As for this write-up, I will treat `key.txt` to contain string `win`.

So, how to recover this `win` flag from `key.txt` using information that `strcmp()` give us?

Well, remember, that `strcmp()` return `1`, `-1`, `0`, depending on str that it compares with?

So, looking at the source code, we have this statement `if (!strcmp(key, argv[1]))`. So `key` which stores our flag is compared with `argv[1]` which is our user-input.

For example, this comparison `strcmp("ab", "aa")`, will return `1`, as first string is `larger` than second string. `strcmp("aa", "ab")` will return `-1` as first string smaller than second string.

So, by using this knowledge, we can work out the flag a character a time. So, we can make an intelligence brute force, where we test different character and compare it with system return value. Here is the command to do it.

```
./runme <string> ; echo $?
```

So, work it out, shall we? *ASCII table should be on your side right now*

```
$ ./runme a ; echo $?   <-- first char should be greater than `a`
1
$ ./runme z ; echo $?   <-- first char should be lower than `z`
255
$ ./runme p ; echo $?
1
$ ./runme w ; echo $?   <-- should be greater than `w`
1
$ ./runme x ; echo $?   <-- but then next char `x` after `w` is returning -1, so this the first character
255
$ ./runme wa ; echo $?
1
$ ./runme wz ; echo $?
255
$ ./runme wp ; echo $?
255
$ ./runme wg ; echo $?
1
$ ./runme wh ; echo $?
1
$ ./runme wi ; echo $?
1
$ ./runme wj ; echo $?
255
$ ./runme wia ; echo $?
1
$ ./runme wiz ; echo $?
255
$ ./runme wip ; echo $?
255
$ ./runme wij ; echo $?
1
$ ./runme wim ; echo $?
1
$ ./runme win ; echo $?  <-- got it!
Winning!
0
```

:)